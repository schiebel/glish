// $Header$

#include "Glish/glish.h"
RCSID("@(#) $Id$")
#include "system.h"

#include <stdlib.h>
#include <string.h>
#include <stream.h>
#include <osfcn.h>
#include <unistd.h>
#include <sys/param.h>
#include <sys/types.h>

#ifdef HAVE_SIGPROCMASK
#include <signal.h>
#endif

#ifdef HAVE_SYS_SELECT_H
#include <sys/select.h>
#endif

#ifndef MAXHOSTNAMELEN
#define MAXHOSTNAMELEN 64
#endif

extern "C" {
char* getenv( const char* );
int isatty( int fd );
int system( const char* string );
}


#include "Npd/npd.h"
#include "Daemon.h"
#include "Reporter.h"
#include "Sequencer.h"
#include "Frame.h"
#include "BuiltIn.h"
#include "Task.h"
#include "input.h"
#include "Channel.h"
#include "Select.h"
#include "Socket.h"
#include "ports.h"
#include "version.h"

#define GLISH_RC_FILE ".glishrc"
#define GLISH_HOME_VAR "GLISH_HOME"

// Time to wait until probing a remote daemon, in seconds.
#define PROBE_DELAY 5

// Interval between subsequent probes, in seconds.
#define PROBE_INTERVAL 5

// Keeps track of the current sequencer...
Sequencer *Sequencer::cur_sequencer = 0;

// A special type of Client used for script clients.  It overrides
// FD_Change() to create or delete ScriptSelectee's as needed.
class ScriptClient : public Client {
public:
	ScriptClient( int& argc, char** argv, int multi = 0 );

	// Inform the ScriptClient as to which selector and agent
	// it should use for getting and propagating events.
	void SetInterface( Selector* selector, Agent* agent );

	// Creates Selectees for each of the event sources if this
	// hasn't already been done. This can only be called after
	// SetInterface() has been called.
	void AddEventSources( );

protected:
	void FD_Change( int fd, int add_flag );

	Selector* selector;
	Agent* agent;
	name_list event_src_list;
	};

// A Selectee corresponding to input for a Glish client.
class ClientSelectee : public Selectee {
    public:
	ClientSelectee( Sequencer* s, Task* t );
	int NotifyOfSelection();

    protected:
	Sequencer* sequencer;
	Task* task;
	};


// A Selectee used only to intercept the initial "established" event
// generated by a local Glish client.  Because we communicate with these
// clients using pipes instead of sockets, we can't use the AcceptSelectee
// (see below) to recognize when they're connecting.
class LocalClientSelectee : public Selectee {
    public:
	LocalClientSelectee( Sequencer* s, Channel* c );
	int NotifyOfSelection();

    protected:
	Sequencer* sequencer;
	Channel* chan;
	};


// A Selectee corresponding to a new request of a client to connect
// to the sequencer.
class AcceptSelectee : public Selectee {
    public:
	AcceptSelectee( Sequencer* s, Socket* conn_socket );
	int NotifyOfSelection();

    protected:
	Sequencer* sequencer;
	Socket* connection_socket;
	};


// A Selectee corresponding to a Glish script's own client.
class ScriptSelectee : public Selectee {
public:
	ScriptSelectee( ScriptClient* client, Agent* agent, int conn_socket );
	int NotifyOfSelection();

protected:
	ScriptClient* script_client;
	Agent* script_agent;
	int connection_socket;
	};


// A Selectee for detecting user input.
class UserInputSelectee : public Selectee {
public:
	UserInputSelectee( int user_fd ) : Selectee( user_fd )	{ }

	// Indicate user input available by signalling to end the
	// select.
	int NotifyOfSelection()	{ return 1; }
	};


// A Selectee for detecting Glish daemon activity.
class DaemonSelectee : public Selectee {
public:
	DaemonSelectee( RemoteDaemon* daemon, Selector* sel, Sequencer* s );

	int NotifyOfSelection();

protected:
	RemoteDaemon* daemon;
	Selector* selector;
	Sequencer* sequencer;
	};


// A SelectTimer for handling glishd probes.
class ProbeTimer : public SelectTimer {
public:
	ProbeTimer( PDict(RemoteDaemon)* daemons, Sequencer* s );

protected:
	int DoExpiration();

	PDict(RemoteDaemon)* daemons;
	Sequencer* sequencer;
	};


// A special type of Agent used for script clients; when it receives
// an event, it propagates it via the ScriptClient object.
class ScriptAgent : public Agent {
public:
	ScriptAgent( Sequencer* s, Client* c ) : Agent(s)	{ client = c; }

	IValue* SendEvent( const char* event_name, parameter_list* args,
			int /* is_request */, int /* log */ )
		{
		IValue* event_val = BuildEventValue( args, 1 );
		client->PostEvent( event_name, event_val, client->LastContext() );
		Unref( event_val );
		return 0;
		}

protected:
	Client* client;
	};


void Scope::MarkGlobalRef(const char *c)
	{
	if ( ! WasGlobalRef( c ) )
		global_refs.Insert( strdup(c), 1 );
	}

void Scope::ClearGlobalRef(const char *c)
	{
	char *v = global_refs.Remove(c);
	if ( v )
		delete v;
	}

Notification::Notification( Agent* arg_notifier, const char* arg_field,
			    IValue* arg_value, Notifiee* arg_notifiee )
	{
	notifier = arg_notifier;
	field = strdup( arg_field );
	value = arg_value;
	notifiee = arg_notifiee;

	Ref( value );
	}

Notification::~Notification()
	{
	delete field;
	Unref( value );
	}

void Notification::Describe( ostream& s ) const
	{
	s << "notification of ";
	notifier->DescribeSelf( s );
	s << "." << field << " (";
	value->DescribeSelf( s );
	s << ") for ";
	notifiee->stmt->DescribeSelf( s );
	}

void Sequencer::InitScriptClient()
	{
	// Create "script" global.
	script_client = new ScriptClient( argc_, argv_, MultiClientScript() );

	if ( script_client->HasSequencerConnection() )
		{
		// Set up script agent to deal with incoming and outgoing
		// events.
		ScriptAgent* script_agent =
			new ScriptAgent( this, script_client );
		script_client->SetInterface( selector, script_agent );
		script_expr->Assign( script_agent->AgentRecord() );

		sys_val->SetField( "is_script_client",
					new IValue( glish_true ) );

		// Include ourselves as an active process; otherwise
		// we'll exit once our child processes are gone.
		++num_active_processes;
		}

	else
		{
		script_expr->Assign( new IValue( glish_false ) );
		sys_val->SetField( "is_script_client",
					new IValue( glish_false ) );
		}

	ScriptCreated( 1 );
	}

Sequencer::Sequencer( int& argc, char**& argv )
	{
	cur_sequencer = this;

	multi_script = 0;
	script_created = 0;
	doing_init = 1;
	argc_ = argc;
	argv_ = argv;

	init_reporters();
	init_values();

	// Create the global scope.
	PushScope( GLOBAL_SCOPE );

	create_built_ins( this, argv[0] );

	null_stmt = new NullStmt;

	stmts = null_stmt;
	last_task_id = my_id = 1;

	await_stmt = except_stmt = 0;
	await_only_flag = 0;
	pending_task = 0;

	maximize_num_fds();

	// avoid SIGPIPE's - they can occur if a client's termination
	// is not detected prior to sending an event to the client
#ifdef HAVE_SIGPROCMASK
	sigset_t sig_mask;
	sigemptyset( &sig_mask );
	sigaddset( &sig_mask, SIGPIPE );
	sigprocmask( SIG_BLOCK, &sig_mask, 0 );
#else
	sigblock( sigmask( SIGPIPE ) );
#endif

	connection_socket = new AcceptSocket( 0, INTERPRETER_DEFAULT_PORT );
	mark_close_on_exec( connection_socket->FD() );

	selector = new Selector;
	selector->AddSelectee( new AcceptSelectee( this, connection_socket ) );
	selector->AddTimer( new ProbeTimer( &daemons, this ) );

	connection_host = local_host_name();
	connection_port = new char[32];
	sprintf( connection_port, "%d", connection_socket->Port() );

	static const char tag_fmt[] = "*tag-%s.%d*";
	int n = strlen( tag_fmt ) + strlen( connection_host ) + /* slop */ 32;

	interpreter_tag = new char[n];
	sprintf( interpreter_tag, tag_fmt, connection_host, int( getpid() ) );

	monitor_task = 0;
	last_notification = 0;
	last_whenever_executed = 0;

	num_active_processes = 0;
	verbose = 0;


	// Create the "system" global variable.
	system_agent = new UserAgent( this );
	sys_val = system_agent->AgentRecord();

	Expr* system_expr = InstallID( strdup( "system" ), GLOBAL_SCOPE );
	system_expr->Assign( sys_val );

	sys_val->SetField( "version", new IValue( GLISH_VERSION ) );


	// Create place for the script variable to be filled in later
	script_expr = InstallID( strdup( "script" ), GLOBAL_SCOPE );
	script_expr->Assign( new IValue( glish_false ) );

	name = argv[0];
	name_list *load_list = new name_list;

	// Skip past client parameters
	int argcnt = 0;
	int found_sep = 0;
	for ( ++argv, --argc; argc > 0; ++argv, --argc, ++argcnt )
		if ( ! strcmp( argv[0], "-+-" ) )
			{
			--argc, ++argv, ++found_sep;
			break;
			}

	if ( ! found_sep )
		{
		argc += argcnt;
		argv -= argcnt;
		}

	// Process startup parameters
	for ( ; argc > 0; ++argv, --argc )
		{
		if ( ! strcmp( argv[0], "-v" ) )
			++verbose;

		else if ( ! strcmp( argv[0], "-l" ) )
			if ( argc > 1 )
				{
				++argv; --argc;
				if ( argv[0] && strlen(argv[0]) )
					load_list->append( argv[0] );
				else
					fatal->Report("bad file name with \"-l\".");
				}
			else
				fatal->Report("\"-l\" given with no file to load.");

		else if ( strchr( argv[0], '=' ) )
			putenv( argv[0] );

		else
			break;
		}

	MakeEnvGlobal();
	BuildSuspendList();

	char* monitor_client_name = getenv( "glish_monitor" );
	if ( monitor_client_name )
		ActivateMonitor( monitor_client_name );

	Parse( glish_init );

	const char *glish_home = getenv( GLISH_HOME_VAR );
	if ( ! glish_home )
		glish_home = GLISH_HOME;

	if ( glish_home )
		{
		char glish_rc_filename[256];
		sprintf( glish_rc_filename, "%s/%s",
				glish_home, GLISH_RC_FILE );

		FILE *glish_rc_file = fopen( glish_rc_filename, "r");

		if ( glish_rc_file )
			{
			fclose( glish_rc_file );
			Parse( glish_rc_filename );
			}
		}

	const char* glish_rc;
	if ( (glish_rc = getenv( "GLISHRC" )) )
		Parse( glish_rc );

	else
		{
		FILE* glish_rc_file = fopen( GLISH_RC_FILE, "r" );
		const char* home;

		if ( glish_rc_file )
			{
			fclose( glish_rc_file );
			Parse( GLISH_RC_FILE );
			}

		else if ( (home = getenv( "HOME" )) )
			{
			char glish_rc_filename[256];
			sprintf( glish_rc_filename, "%s/%s",
					home, GLISH_RC_FILE );

			if ( (glish_rc_file = fopen( glish_rc_filename, "r")) )
				{
				fclose( glish_rc_file );
				Parse( glish_rc_filename );
				}
			}
		}


	if ( load_list->length() )
		{
		// Handle the .glishrc startup so that we can use any include
		// path which might be specified in there.
		Exec( 1 );
		loop_over_list( *load_list, i )
			{
			char *expanded_name = which_include((*load_list)[i]);
			if ( expanded_name )
				load_list->replace(i,expanded_name);
			else
				fatal->Report("Can't include file \"",
						      (*load_list)[i],"\".");
			}

		// Prevent re-executing the .glishrc statements
		stmts = null_stmt;
		loop_over_list( *load_list, j )
			Parse( (*load_list)[j] );

		delete_name_list( load_list );
		}

	int do_interactive = 1;

	if ( argc > 0 && strcmp( argv[0], "--" ) )
		{ // We have a file to parse.
		// Handle the .glishrc (or "-l") startup scripts so that we can use any
		// include path which might be specified in there.
		Exec( 1 );
		// Prevent re-executing the .glishrc statements
		stmts = null_stmt;
		Parse( argv[0] );
		do_interactive = 0;
		++argv, --argc;
		}

	if ( ! ScriptCreated() )
		InitScriptClient();

	MakeArgvGlobal( argv, argc );

	if ( do_interactive )
		Parse( stdin );
	}


Sequencer::~Sequencer()
	{
	delete script_client;
	delete selector;
	delete connection_socket;
	delete connection_port;
	delete interpreter_tag;
	}


void Sequencer::AddBuiltIn( BuiltIn* built_in )
	{
	Expr* id = InstallID( strdup( built_in->Name() ), GLOBAL_SCOPE );
	id->Assign( new IValue( built_in ) );
	}


void Sequencer::QueueNotification( Notification* n )
	{
	if ( verbose > 1 )
		message->Report( "queueing", n );

	notification_queue.EnQueue( n );
	}


void Sequencer::PushScope( scope_type s )
	{
	Scope *newscope = new Scope( s );
	scopes.append( newscope );
	if ( s != LOCAL_SCOPE )
		global_scopes.append( scopes.length() - 1 );
	}

int Sequencer::PopScope()
	{
	int top_scope_pos = scopes.length() - 1;

	if ( top_scope_pos < 0 )
		fatal->Report( "scope underflow in Sequencer::PopScope" );

	Scope* top_scope = scopes[top_scope_pos];
	int frame_size = top_scope->Length();

	scopes.remove( top_scope );

	if ( top_scope->GetScopeType() != LOCAL_SCOPE )
		global_scopes.remove( top_scope_pos );

	delete top_scope;

	return frame_size;
	}

scope_type Sequencer::GetScopeType() const
	{
	int s_index = scopes.length() - 1;

        if ( ! s_index )
		return GLOBAL_SCOPE;

	int gs_index = global_scopes.length();
	if (  gs_index && global_scopes[--gs_index] == s_index )
		return FUNC_SCOPE;

	return LOCAL_SCOPE;
	}

Scope *Sequencer::GetScope( )
	{
	if ( scopes.length() )
		return scopes[0];
	else
		return 0;
	}

Expr* Sequencer::InstallID( char* id, scope_type scope, int do_warn,
				int GlobalRef, int FrameOffset )
	{
	int scope_index;
	int scope_offset = 0;
	int gs_index = global_scopes.length() - 1;

	if ( GlobalRef )
		scope = LOCAL_SCOPE;

	switch ( scope )
		{
		case LOCAL_SCOPE:
			scope_index = scopes.length() - 1;

			if ( GlobalRef )
				scope_offset = -scope_index;
			else
				{
				int goff = global_scopes[gs_index];
				if ( scopes[goff]->GetScopeType() != GLOBAL_SCOPE )
					scope_offset = scope_index - goff;
				}
			break;
		case FUNC_SCOPE:
			scope_index = global_scopes[gs_index];
			break;
		case GLOBAL_SCOPE:
			scope_index = 0;
			break;
		default:
			fatal->Report("bad scope tag in Sequencer::InstallID()" );

		}

	Scope *cur_scope = scopes[scope_index];
	
	scope = cur_scope->GetScopeType();

	int frame_offset = GlobalRef ? FrameOffset : cur_scope->Length();

	Expr* result = CreateVarExpr( id, scope, scope_offset, frame_offset, this );

	if ( cur_scope->WasGlobalRef( id ) )
		{
		cur_scope->ClearGlobalRef( id );
		if ( do_warn )
			warn->Report( "scope of \"", id,"\" goes from global to local");
		}

	cur_scope->Insert( id, result );

	if ( scope == GLOBAL_SCOPE )
		{
		global_frame.append( 0 );
		if ( GetScopeType() != GLOBAL_SCOPE && ! GlobalRef )
			InstallID( id, LOCAL_SCOPE, do_warn, 1, frame_offset );
		}

	return result;
	}

Expr* Sequencer::LookupID( char* id, scope_type scope, int do_install, int do_warn )
	{
	Expr *result = 0;

	switch ( scope )
		{
		case ANY_SCOPE:
			{
			int off = scopes.length()-1;
			for ( int cnt = off; ! result && cnt >= 0; cnt-- )
				result = (*scopes[cnt])[id];

			if ( off != cnt+1 )
				scopes[off]->MarkGlobalRef( id );

			if ( ! result && do_install )
				return InstallID( id, GLOBAL_SCOPE, do_warn );
			}
			break;
		case LOCAL_SCOPE:
			{
			for ( int cnt = scopes.length()-1; ! result && cnt >= 0; cnt-- )
				{
				result = (*scopes[cnt])[id];
				if ( scopes[cnt]->GetScopeType() != LOCAL_SCOPE )
					break;
				}
			if ( ! result && do_install )
				return InstallID( id, FUNC_SCOPE, do_warn );
			}
			break;
		case FUNC_SCOPE:
			{
			int cnt = global_scopes.length() - 1;
			int offset = global_scopes[cnt];
			result = (*scopes[offset])[id];
			if ( ! result && do_install )
				return InstallID( id, FUNC_SCOPE, do_warn );
			}
			break;
		case GLOBAL_SCOPE:
			result = (*scopes[0])[id];
			if ( ! result && do_install )
				return InstallID( id, GLOBAL_SCOPE, do_warn );
			if ( result && GetScopeType() != GLOBAL_SCOPE )
				return InstallID( id, LOCAL_SCOPE, do_warn, 1, ((VarExpr*)result)->offset() );
			break;
		default:
			fatal->Report("bad scope tag in Sequencer::LookupID()" );

		}

	delete id;
	return result;
	}

Expr *Sequencer::InstallVar( char* id, scope_type scope, VarExpr *var )
	{
	int scope_index;
	int scope_offset = 0;
	int gs_index = global_scopes.length() - 1;

	switch ( scope )
		{
		case LOCAL_SCOPE:
			{
			scope_index = scopes.length() - 1;

			int goff = global_scopes[gs_index];
			if ( scopes[goff]->GetScopeType() != GLOBAL_SCOPE )
				scope_offset = scope_index - goff;
			}
			break;
		case FUNC_SCOPE:
			scope_index = global_scopes[gs_index];
			break;
		case GLOBAL_SCOPE:
			scope_index = 0;
			break;
		default:
			fatal->Report("bad scope tag in Sequencer::InstallID()" );

		}

	Scope *cur_scope = scopes[scope_index];
	
	scope = cur_scope->GetScopeType();

	int frame_offset = cur_scope->Length();

	var->set( scope, scope_offset, frame_offset );

	if ( cur_scope->WasGlobalRef( id ) )
		{
		cur_scope->ClearGlobalRef( id );
		warn->Report( "scope of \"", id,"\" goes from global to local");
		}

	cur_scope->Insert( id, var );

	if ( scope == GLOBAL_SCOPE )
		global_frame.append( 0 );

	return var;
	}

Expr *Sequencer::LookupVar( char* id, scope_type scope, VarExpr *var )
	{
	Expr *result = 0;

	switch ( scope )
		{
		case ANY_SCOPE:
			{
			int off = scopes.length()-1;
			for ( int cnt = off; ! result && cnt >= 0; cnt-- )
				result = (*scopes[cnt])[id];

			if ( off != cnt+1 )
				scopes[off]->MarkGlobalRef( id );

			if ( ! result )
				return InstallVar( id, GLOBAL_SCOPE, var );
			}
			break;
		case LOCAL_SCOPE:
			{
			for ( int cnt = scopes.length()-1; ! result && cnt >= 0; cnt-- )
				{
				result = (*scopes[cnt])[id];
				if ( scopes[cnt]->GetScopeType() != LOCAL_SCOPE )
					break;
				}
			if ( ! result )
				return InstallVar( id, FUNC_SCOPE, var );
			}
			break;
		case FUNC_SCOPE:
			{
			int cnt = global_scopes.length() - 1;
			int offset = global_scopes[cnt];
			result = (*scopes[offset])[id];
			if ( ! result )
				return InstallVar( id, FUNC_SCOPE, var );
			}
			break;
		case GLOBAL_SCOPE:
			result = (*scopes[0])[id];
			if ( ! result )
				return InstallVar( id, GLOBAL_SCOPE, var );
			break;
		default:
			fatal->Report("bad scope tag in Sequencer::LookupID()" );

		}
//	delete id;
	return result;
	}

const IValue *Sequencer::LookupVal( const char *id )
	{
	Expr *expr = 0;
	const IValue *val = 0;
	if ( cur_sequencer && (expr = cur_sequencer->LookupID( strdup( id ), GLOBAL_SCOPE, 0 )) )
		{
		val = expr->ReadOnlyEval();
		expr->ReadOnlyDone( val );	// **BUG**
		}
	return val;
	}
	

void Sequencer::PushFrame( Frame* new_frame )
	{
	frames.append( new_frame );
	if ( new_frame->GetScopeType() != LOCAL_SCOPE )
		global_frames.append( frames.length() - 1 );
	}

Frame* Sequencer::PopFrame()
	{
	int top_frame_pos = frames.length() - 1;
	if ( top_frame_pos < 0 )
		fatal->Report(
			"local frame stack underflow in Sequencer::PopFrame" );

	Frame *top_frame = frames.remove_nth( top_frame_pos );
	if ( top_frame->GetScopeType() != LOCAL_SCOPE )
		global_frames.remove( top_frame_pos );

	return top_frame;
	}

Frame* Sequencer::CurrentFrame()
	{
	int top_frame = frames.length() - 1;
	if ( top_frame < 0 )
		return 0;

	return frames[top_frame];
	}


IValue* Sequencer::FrameElement( scope_type scope, int scope_offset,
					int frame_offset )
	{
	if ( scope_offset < 0 )
		scope = GLOBAL_SCOPE;

	switch ( scope )
		{
		case LOCAL_SCOPE:
			{
			int offset = scope_offset;
			int gs_off = global_frames.length() - 1;

			if ( gs_off >= 0 )
				offset += global_frames[gs_off];

			if ( offset < 0 || offset >= frames.length() )
				fatal->Report(
		    "local frame error in Sequencer::FrameElement (",
		    scope_offset, ",", gs_off ? global_frames[gs_off] : -1,
		    "," , frames.length(), ")" );

			return frames[offset]->FrameElement( frame_offset );
			}
			break;
		case FUNC_SCOPE:
			{
			int gs_off = global_frames.length() - 1;
			int offset = global_frames[gs_off];

			if ( offset < 0 || offset >= frames.length() )
				fatal->Report(
		    "local frame error in Sequencer::FrameElement (",
		    offset, " (", gs_off, "), ", frames.length(), ")" );

			return frames[offset]->FrameElement( frame_offset );
			}
			break;
		case GLOBAL_SCOPE:
			{
			if ( frame_offset < 0 || frame_offset >= global_frame.length() )
				fatal->Report(
				"bad global frame offset in Sequencer::FrameElement" );
			return global_frame[frame_offset];
			}
			break;
		default:
			fatal->Report("bad scope tag in Sequencer::FrameElement()" );
		}
	}

void Sequencer::SetFrameElement( scope_type scope, int scope_offset,
					int frame_offset, IValue* value )
	{
	IValue* prev_value;

	if ( scope_offset < 0 )
		scope = GLOBAL_SCOPE;

	switch ( scope )
		{
		case LOCAL_SCOPE:
			{
			int offset = scope_offset;
			int gs_off = global_frames.length() - 1;

			if ( gs_off >= 0 )
				offset += global_frames[gs_off];

			if ( offset < 0 || offset >= frames.length() )
				fatal->Report(
		    "local frame error in Sequencer::SetFrameElement (",
		    scope_offset, ",", gs_off ? global_frames[gs_off] : -1,
		    "," , frames.length(), ")" );

			IValue*& frame_value =
				frames[offset]->FrameElement( frame_offset );
			prev_value = frame_value;
			frame_value = value;
			}
			break;
		case FUNC_SCOPE:
			{
			int gs_off = global_frames.length() - 1;
			int offset = global_frames[gs_off];

			if ( offset < 0 || offset >= frames.length() )
				fatal->Report(
		    "local frame error in Sequencer::SetFrameElement (",
		    offset, " (", gs_off, "), ", frames.length(), ")" );

			IValue*& frame_value =
				frames[offset]->FrameElement( frame_offset );
			prev_value = frame_value;
			frame_value = value;
			}
			break;
		case GLOBAL_SCOPE:
			{
			if ( frame_offset < 0 || frame_offset >= global_frame.length() )
				fatal->Report(
				"bad global frame offset in Sequencer::FrameElement" );
			prev_value = global_frame.replace( frame_offset, value );
			}
			break;
		default:
			fatal->Report("bad scope tag in Sequencer::SetFrameElement()" );


		}
	Unref( prev_value );
	}


char* Sequencer::RegisterTask( Task* new_task )
	{
	char buf[128];
	sprintf( buf, "task%d", ++last_task_id );

	char* new_ID = strdup( buf );

	ids_to_tasks.Insert( new_ID, new_task );

	return new_ID;
	}

void Sequencer::DeleteTask( Task* task )
	{
	(void) ids_to_tasks.Remove( task->TaskID() );
	}


void Sequencer::AddStmt( Stmt* addl_stmt )
	{
	stmts = merge_stmts( stmts, addl_stmt );
	}


int Sequencer::RegisterStmt( Stmt* stmt )
	{
	registered_stmts.append( stmt );
	return registered_stmts.length();
	}

Stmt* Sequencer::LookupStmt( int index )
	{
	if ( index <= 0 || index > registered_stmts.length() )
		return 0;

	return registered_stmts[index - 1];
	}

int Sequencer::LocalHost( const char *host )
	{
	if ( ! host ||
	     ! strcmp( host, ConnectionHost() ) ||
	     ! strcmp( host, "localhost" ) )
		return 1;
	else
		return 0;
	}

Channel* Sequencer::GetHostDaemon( const char* host, int &err )
	{
	err = 0;
	RemoteDaemon* d;

	if ( LocalHost( host ) )
		{
		// Check to see if a daemon is running
		d = daemons["localhost"];
		if ( ! d )
			d = OpenDaemonConnection( "localhost", err );
		}
	else 
		{
		d = daemons[host];
		if ( ! d )
			d = CreateDaemon( host );
		if ( ! d )
			err = 1;
		}
		
	return d ? d->DaemonChannel() : 0;
	}


void Sequencer::Exec( int startup_script )
	{
	if ( interactive )
		return;

	if ( error->Count() > 0 )
		{
		message->Report( "execution aborted" );
		return;
		}

	stmt_flow_type flow;
	Unref( stmts->Exec( 0, flow ) );

	if ( ! startup_script )
		EventLoop();
	}


void Sequencer::Await( Stmt* arg_await_stmt, int only_flag,
			Stmt* arg_except_stmt )
	{
	int removed_yyin = 0;

	Stmt* hold_await_stmt = await_stmt;
	int hold_only_flag = await_only_flag;
	Stmt* hold_except_stmt = except_stmt;

	await_stmt = arg_await_stmt;
	await_only_flag = only_flag;
	except_stmt = arg_except_stmt;

	if ( yyin && isatty( fileno( yyin ) ) && 
			selector->FindSelectee( fileno( yyin ) ) )
		{
		selector->DeleteSelectee( fileno( yyin ) );
		removed_yyin = 1;
		}

	EventLoop();

	if ( yyin && isatty( fileno( yyin ) ) && removed_yyin )
		selector->AddSelectee( new UserInputSelectee( fileno( yyin ) ) );

	await_stmt = hold_await_stmt;
	await_only_flag = only_flag;
	except_stmt = hold_except_stmt;
	}


IValue* Sequencer::AwaitReply( Task* task, const char* event_name,
				const char* reply_name )
	{
	GlishEvent* reply = recv_event( task->GetChannel()->ReadFD() );
	IValue* result = 0;

	if ( ! reply )
		{
		warn->Report( task, " terminated without replying to ",
				event_name, " request" );
		result = error_ivalue();
		}

	else if ( ! strcmp( reply->name, reply_name ) )
		{
		result = (IValue*) reply->value;
		Ref( result );
		}

	else
		{
		warn->Report( "expected reply from ", task, " to ",
				event_name, " request, instead got \"",
				reply->name, "\"" );

		Ref( reply );	// So NewEvent doesn't throw it away.
		NewEvent( task, reply );

		result = (IValue*) reply->value;
		Ref( result );	// So following Unref doesn't discard value.
		}

	Unref( reply );

	return result;
	}


Channel* Sequencer::AddLocalClient( int read_fd, int write_fd )
	{
	Channel* c = new Channel( read_fd, write_fd );
	Selectee* s = new LocalClientSelectee( this, c );

	selector->AddSelectee( s );

	return c;
	}


Channel* Sequencer::WaitForTaskConnection( Task* task )
	{
	Task* t;
	Channel* chan;

	// Need to loop because perhaps we'll receive connections
	// from tasks other than the one we're waiting for.
	do
		{
		int new_conn = accept_connection( connection_socket->FD() );
		mark_close_on_exec( new_conn );

		chan = new Channel( new_conn, new_conn );
		t = NewConnection( chan );
		}
	while ( t && t != task );

	if ( t )
		return chan;
	else
		return 0;
	}

Task* Sequencer::NewConnection( Channel* connection_channel )
	{
	GlishEvent* establish_event =
		recv_event( connection_channel->ReadFD() );

	// It's possible there's already a Selectee for this channel,
	// due to using a LocalClientSelectee.  If so, remove it, so
	// it doesn't trigger additional activity.
	RemoveSelectee( connection_channel );

	if ( ! establish_event )
		{
		error->Report( "new connection immediately broken" );
		return 0;
		}

	IValue* v = (IValue*) (establish_event->value);
	char* task_id;
	int protocol;

	if ( v->Type() == TYPE_STRING )
		{
		task_id = v->StringVal();
		protocol = 1;
		}

	else if ( ! v->FieldVal( "name", task_id ) ||
		  ! v->FieldVal( "protocol", protocol ) )
		{
		error->Report( "bad connection establishment" );
		return 0;
		}

	// ### Should check for protocol compatibility here.

	Task* task = ids_to_tasks[task_id];

	if ( ! task )
		{
		error->Report( "connection received from non-existent task ",
				task_id );
		Unref( establish_event );
		return 0;
		}

	else
		{
		task->SetProtocol( protocol );
		AssociateTaskWithChannel( task, connection_channel );
		NewEvent( task, establish_event );
		}

	delete task_id;

	return task;
	}


void Sequencer::AssociateTaskWithChannel( Task* task, Channel* chan )
	{
	task->SetChannel( chan, selector );
	task->SetActive();

	selector->AddSelectee( new ClientSelectee( this, task ) );

	// empty out buffer so subsequent select()'s will work
	if ( chan->DataInBuffer() )
		EmptyTaskChannel( task );
	}

void Sequencer::RemoveSelectee( Channel* chan )
	{
	if ( selector->FindSelectee( chan->ReadFD() ) )
		selector->DeleteSelectee( chan->ReadFD() );
	}


int Sequencer::NewEvent( Task* task, GlishEvent* event )
	{
	if ( ! event )
		{ // task termination
		task->CloseChannel();

		if ( ! task->Active() )
			return 0;

		// Abnormal termination - no "done" message first.
		event = new GlishEvent( (const char*) "fail",
					(Value*)(new IValue( task->AgentID() )) );
		}

	const char* event_name = event->name;
	IValue* value = (IValue*)event->value;

	if ( verbose > 0 )
		message->Report( name, ": received event ",
				 task->Name(), ".", event_name, " ", value );

	if ( monitor_task && task != monitor_task )
		LogEvent( task->TaskID(), task->Name(), event_name, value, 1 );

	// If true, generate message if no interest in event.
	int complain_if_no_interest = 0;

	if ( ! strcmp( event_name, "established" ) )
		{
		// We already did the SetActive() when the channel
		// was established.
		}

	else if ( ! strcmp( event_name, "done" ) )
		task->SetDone();

	else if ( ! strcmp( event_name, "fail" ) )
		{
		task->SetDone();
		complain_if_no_interest = 1;
		}

	else if ( ! strcmp( event_name, "*rendezvous*" ) )
		Rendezvous( event_name, value );

	else if ( ! strcmp( event_name, "*forward*" ) )
		ForwardEvent( event_name, value );

	else
		complain_if_no_interest = 1;

	int ignore_event = 0;
	int await_finished = 0;

	if ( await_stmt )
		{
		await_finished =
			task->HasRegisteredInterest( await_stmt, event_name );

		if ( ! await_finished && await_only_flag &&
		     ! task->HasRegisteredInterest( except_stmt, event_name ) )
			ignore_event = 1;
		}

	if ( ignore_event )
		warn->Report( "event ", task->Name(), ".", event_name,
			      " ignored due to \"await\"" );

	else
		{
		// We're going to want to keep the event value as a field
		// in the task's AgentRecord.
		Ref( value );

		int was_interest = task->CreateEvent( event_name, value );

		if ( ! was_interest && complain_if_no_interest )
			warn->Report( "event ", task->Name(), ".", event_name,
					" (", value, ") dropped" );

		RunQueue();	// process effects of CreateEvent()
		}

	Unref( event );

	if ( await_finished )
		{
		pending_task = task;

		// Make sure the pending task isn't delete'd before
		// we can exhaust its pending input.

		Ref( pending_task );

		return 1;
		}

	else
		return 0;
	}


void Sequencer::NewClientStarted()
	{
	++num_active_processes;
	}


int Sequencer::ShouldSuspend( const char* task_var_ID )
	{
	if ( task_var_ID )
		return suspend_list[task_var_ID];
	else
		// This is an anonymous client - don't suspend.
		return 0;
	}

int Sequencer::EmptyTaskChannel( Task* task, int force_read )
	{
	int status = 0;

	if ( task->Active() )
		{
		Channel* c = task->GetChannel();
		ChanState old_state = c->ChannelState();

		c->ChannelState() = CHAN_IN_USE;

		if ( force_read )
			status = NewEvent( task, recv_event( c->ReadFD() ) );

		while ( status == 0 &&
			c->ChannelState() == CHAN_IN_USE &&
			c->DataInBuffer() )
			{
			status = NewEvent( task, recv_event( c->ReadFD() ) );
			}

		if ( c->ChannelState() == CHAN_INVALID )
			{ // This happens iff the given task has exited
			selector->DeleteSelectee( c->ReadFD() );
			delete c;

			while ( reap_terminated_process() )
				;

			--num_active_processes;
			}

		else
			c->ChannelState() = old_state;
		}

	return status;
	}


void Sequencer::MakeEnvGlobal()
	{
	IValue* env_value = create_irecord();

	extern char** environ;
	for ( char** env_ptr = environ; *env_ptr; ++env_ptr )
		{
		char* delim = strchr( *env_ptr, '=' );

		if ( delim )
			{
			*delim = '\0';
			env_value->AssignRecordElement( *env_ptr,
						    new IValue( delim + 1 ) );
			*delim = '=';
			}
		else
			env_value->AssignRecordElement( *env_ptr,
						new IValue( glish_false ) );
		}

	Expr* env_expr = LookupID( strdup( "environ" ), GLOBAL_SCOPE );
	env_expr->Assign( env_value );
	}


void Sequencer::MakeArgvGlobal( char** argv, int argc )
	{
	// If there's an initial "--" argument, remove it, it's a vestige
	// from when "--" was needed to separate script files from their
	// arguments.
	if ( argc > 0 && ! strcmp( argv[0], "--" ) )
		++argv, --argc;

	IValue* argv_value = new IValue( (charptr*) argv, argc, COPY_ARRAY );
	Expr* argv_expr = LookupID( strdup( "argv" ), GLOBAL_SCOPE );
	argv_expr->Assign( argv_value );
	}


void Sequencer::BuildSuspendList()
	{
	char* suspend_env_list = getenv( "suspend" );

	if ( ! suspend_env_list )
		return;

	char* suspendee = strtok( suspend_env_list, " " );

	while ( suspendee )
		{
		suspend_list.Insert( suspendee, 1 );
		suspendee = strtok( 0, " " );
		}
	}


void Sequencer::Parse( FILE* file, const char* filename )
	{
	restart_yylex( file );

	yyin = file;
	current_sequencer = this;
	line_num = 1;
	input_file_name = filename ? strdup( filename ) : 0;

	if ( yyin && isatty( fileno( yyin ) ) )
		{
		message->Report( "Glish version ", GLISH_VERSION, "." );

		// We're about to enter the "interactive" loop, so
		// first execute any statements we've seen so far due
		// to .glishrc files.
		Exec( 1 );

		// And add a special Selectee for detecting user input.
		selector->AddSelectee( new UserInputSelectee( fileno( yyin ) ) );
		interactive = 1;
		}
	else
		interactive = 0;

	if ( yyparse() )
		error->Report( "syntax errors parsing input" );

	// Don't need to delete input_file_name, yylex() already did
	// that on <<EOF>>.
	input_file_name = 0;

	line_num = 0;
	}


void Sequencer::Parse( const char file[] )
	{
	FILE* f = fopen( file, "r" );

	if ( ! f )
		error->Report( "can't open file \"", file, "\"" );
	else
		Parse( f, file );
	}

void Sequencer::Parse( const char* strings[] )
	{
	scan_strings( strings );
	Parse( 0, "glish internal initialization" );
	}


RemoteDaemon* Sequencer::CreateDaemon( const char* host )
	{
	int err = 0;
	RemoteDaemon* rd = OpenDaemonConnection( host, err );
	if ( err ) return 0;

	if ( rd )
		// We're all done, the daemon was already running.
		return rd;

	// Have to start up the daemon.
	message->Report( "activating Glish daemon on ", host );

	start_remote_daemon( host );

	rd = OpenDaemonConnection( host, err );
	if ( err ) return 0;
	while ( ! rd )
		{
		message->Report( "waiting for daemon ..." );
		sleep( 1 );
		rd = OpenDaemonConnection( host, err );
		if ( err ) return 0;
		}

	return rd;
	}

RemoteDaemon* Sequencer::OpenDaemonConnection( const char* host, int &err )
	{
	RemoteDaemon *r = 0;
	err = 0;
	const char *h = host;

	if ( ! strcmp(h,"localhost") )
		h = ConnectionHost();

	if (r = connect_to_daemon( h, err ) )
		{
		daemons.Insert( strdup( host ), r );
		selector->AddSelectee(new DaemonSelectee( r, selector, this ) );
		}

	return r;
	}


void Sequencer::ActivateMonitor( char* monitor_client_name )
	{
	TaskAttr* monitor_attrs =
		new TaskAttr( "*monitor*", "localhost", 0, 0, 0, 0 );

	const_args_list monitor_args;
	monitor_args.append( new IValue( monitor_client_name ) );

	monitor_task = new ClientTask( &monitor_args, monitor_attrs, this );

	if ( monitor_task->TaskError() )
		{
		Unref( monitor_task );
		monitor_task = 0;
		}
	}


void Sequencer::LogEvent( const char* gid, const char* id,
			const char* event_name, const IValue* event_value,
			int is_inbound )
	{
	if ( ! monitor_task )
		return;

	IValue gid_value( gid );
	IValue id_value( id );
	IValue name_value( event_name );

	parameter_list args;

	ConstExpr gid_expr( &gid_value );
	ConstExpr id_expr( &id_value );
	ConstExpr name_expr( &name_value );
	ConstExpr value_expr( event_value );

	Parameter gid_param( "glish_id", VAL_VAL, &gid_expr, 0 );
	Parameter id_param( "id", VAL_VAL, &id_expr, 0 );
	Parameter name_param( "name", VAL_VAL, &name_expr, 0 );
	Parameter value_param( "value", VAL_VAL, &value_expr, 0 );

	args.insert( &name_param );
	args.insert( &id_param );
	args.insert( &gid_param );
	args.insert( &value_param );

	const char* monitor_event_name = is_inbound ? "event_in" : "event_out";
	monitor_task->SendEvent( monitor_event_name, &args, 0, 0 );
	}

void Sequencer::LogEvent( const char* gid, const char* id, const GlishEvent* e,
			int is_inbound )
	{
	LogEvent( gid, id, e->name, (IValue*) (e->value), is_inbound );
	}


void Sequencer::SystemEvent( const char* name, const IValue* val )
	{
	system_agent->SendSingleValueEvent( name, val, 1 );
	}


void Sequencer::Rendezvous( const char* event_name, IValue* value )
	{
	char* source_id;
	char* sink_id;

	if ( ! value->FieldVal( "source_id", source_id ) ||
	     ! value->FieldVal( "sink_id", sink_id ) )
		fatal->Report( "bad internal", event_name, "event" );

	Task* src = ids_to_tasks[source_id];
	Task* snk = ids_to_tasks[sink_id];

	if ( ! src || ! snk )
		fatal->Report( "no such source or sink ID in internal",
				event_name, "event:", source_id, sink_id );

	// By sending out these two events immediately, before any other
	// *rendezvous* events can arise, we impose a serial ordering on
	// all rendezvous.  This avoids deadlock.
	//
	// Actually, now that we always use sockets (even locally), the
	// following isn't necessary, since connecting to a socket won't
	// block (unless the "listen" queue for the remote socket is
	// full).  We could just pass along the *rendezvous-resp* event
	// to the sink and be done with it.  But we retain the protocol
	// because it was a lot of work getting it right and we don't want
	// to have to figure it out again if for some reason we don't
	// always use sockets.
	src->SendSingleValueEvent( "*rendezvous-orig*", value, 1 );
	snk->SendSingleValueEvent( "*rendezvous-resp*", value, 1 );

	delete source_id;
	delete sink_id;
	}


void Sequencer::ForwardEvent( const char* event_name, IValue* value )
	{
	char* receipient_id;
	char* new_event_name;

	if ( ! value->FieldVal( "receipient", receipient_id ) ||
	     ! value->FieldVal( "event", new_event_name ) )
		fatal->Report( "bad internal event \"", event_name, "\"" );

	Task* task = ids_to_tasks[receipient_id];

	if ( ! task )
		fatal->Report( "no such receipient ID in ", event_name,
				"internal event:", receipient_id );

	task->SendSingleValueEvent( new_event_name, value, 1 );

	delete receipient_id;
	delete new_event_name;
	}


void Sequencer::EventLoop()
	{
	RunQueue();

	if ( pending_task )
		{
		EmptyTaskChannel( pending_task );

		// We Ref()'d the pending_task when assigning it, to make
		// sure it didn't go away due to the effects of RunQueue().

		Unref( pending_task );

		pending_task = 0;
		}

#if defined( GLISHTK )
	while ( (ActiveClients() || tk_NumMainWindows > 0) && ! selector->DoSelection() )
#else
	while ( ActiveClients() && ! selector->DoSelection() )
#endif
		RunQueue();
	}


void Sequencer::RunQueue()
	{
	Notification* n;

	while ( (n = notification_queue.DeQueue()) )
		{
		if ( verbose > 1 )
			message->Report( "doing", n );

		if ( n->notifiee->frame )
			PushFrame( n->notifiee->frame );

		IValue* notifier_val = n->notifier->AgentRecord();

		if ( notifier_val->Type() == TYPE_RECORD &&
		     notifier_val->HasRecordElement( n->field ) != n->value )
			// Need to assign the event value.
			notifier_val->AssignRecordElement( n->field, n->value );

		// There are a bunch of Ref's and Unref's here because the
		// Notify() call below can lead to a recursive call to this
		// routine (due to an "await" statement), so 'n' might
		// otherwise be deleted underneath our feet.
		Unref( last_notification );
		last_notification = n;

		Ref( n );
		n->notifiee->stmt->Notify( n->notifier );

		if ( n->notifiee->frame )
			(void) PopFrame();
		Unref( n );
		}
	}

ClientSelectee::ClientSelectee( Sequencer* s, Task* t )
    : Selectee( t->GetChannel()->ReadFD() )
	{
	sequencer = s;
	task = t;
	}

int ClientSelectee::NotifyOfSelection()
	{
	return sequencer->EmptyTaskChannel( task, 1 );
	}


LocalClientSelectee::LocalClientSelectee( Sequencer* s, Channel* c )
    : Selectee( c->ReadFD() )
	{
	sequencer = s;
	chan = c;
	}

int LocalClientSelectee::NotifyOfSelection()
	{
	(void) sequencer->NewConnection( chan );
	return 0;
	}


AcceptSelectee::AcceptSelectee( Sequencer* s, Socket* conn_socket )
    : Selectee( conn_socket->FD() )
	{
	sequencer = s;
	connection_socket = conn_socket;
	}

int AcceptSelectee::NotifyOfSelection()
	{
	int new_conn;

	if ( connection_socket->IsLocal() )
		new_conn = accept_local_connection( connection_socket->FD() );
	else
		new_conn = accept_connection( connection_socket->FD() );

	mark_close_on_exec( new_conn );

	(void) sequencer->NewConnection( new Channel( new_conn, new_conn ) );

	return 0;
	}


ScriptSelectee::ScriptSelectee( ScriptClient* client, Agent* agent, int conn_socket )
    : Selectee( conn_socket )
	{
	script_client = client;
	script_agent = agent;
	connection_socket = conn_socket;
	}

int ScriptSelectee::NotifyOfSelection()
	{
	fd_set fd_mask;

	FD_ZERO( &fd_mask );
	FD_SET( connection_socket, &fd_mask );

	GlishEvent* e = script_client->NextEvent( &fd_mask );
	script_client->AddEventSources();

	if ( ! e )
		{
		delete script_client;
		exit( 0 );
		}

	// Ref() the value, since CreateEvent is going to Unref() it, and the
	// script_client is also going to Unref() it via Unref()'ing the
	// whole GlishEvent.
	Ref( e->value );

	script_agent->CreateEvent( e->name, (IValue*)(e->value) );

	return 0;
	}


DaemonSelectee::DaemonSelectee( RemoteDaemon* arg_daemon, Selector* sel,
				Sequencer* s )
: Selectee( arg_daemon->DaemonChannel()->ReadFD() )
	{
	daemon = arg_daemon;
	selector = sel;
	sequencer = s;
	}

int DaemonSelectee::NotifyOfSelection()
	{
	int fd = daemon->DaemonChannel()->ReadFD();
	GlishEvent* e = recv_event( fd );

	const char* message_name = 0;

	if ( e )
		{
		if ( ! strcmp( e->name, "probe-reply" ) )
			{
			if ( daemon->State() == DAEMON_LOST )
				{
				message->Report( "connectivity to daemon @ ",
						daemon->Host(), " restored" );
				message_name = "connection_restored";
				}

			daemon->SetState( DAEMON_OK );
			}

		else
			{
			error->Report(
				"received unsolicited message from daemon @ ",
					daemon->Host() );
			}

		Unref( e );
		}

	else
		{
		error->Report( "Glish daemon @ ", daemon->Host(),
				" terminated" );
		selector->DeleteSelectee( fd );
		message_name = "daemon_terminated";
		}

	if ( message_name )
		{
		IValue message_val( daemon->Host() );
		sequencer->SystemEvent( message_name, &message_val );
		}

	return 0;
	}


ProbeTimer::ProbeTimer( PDict(RemoteDaemon)* arg_daemons, Sequencer* s )
: SelectTimer( PROBE_DELAY, 0, PROBE_INTERVAL, 0 )
	{
	daemons = arg_daemons;
	sequencer = s;
	}

int ProbeTimer::DoExpiration()
	{
	IterCookie* c = daemons->InitForIteration();

	RemoteDaemon* r;
	const char* key;
	while ( (r = daemons->NextEntry( key, c )) )
		{
		if ( r->State() == DAEMON_REPLY_PENDING )
			{ // Oops.  Haven't gotten a reply from our last probe.
			warn->Report( "connection to Glish daemon @ ", key,
					" lost" );
			r->SetState( DAEMON_LOST );

			IValue message_val( r->Host() );
			sequencer->SystemEvent( "connection_lost",
						&message_val );
			}

		// Probe the daemon, regardless of its state.
		send_event( r->DaemonChannel()->WriteFD(), "probe",
				false_value );

		if ( r->State() == DAEMON_OK )
			r->SetState( DAEMON_REPLY_PENDING );
		}

	return 1;
	}


ScriptClient::ScriptClient( int& argc, char** argv, int multi ) : Client( argc, argv, multi )
	{
	selector = 0;
	agent = 0;
	}

void ScriptClient::SetInterface( Selector* s, Agent* a )
	{
	selector = s;
	agent = a;
	AddEventSources();
	}

void ScriptClient::AddEventSources()
	{
	int read_fd = fileno( stdin );
	int got_src = 0;

	if ( event_src_list.length() == event_sources.length() )
		return;

	loop_over_list( event_sources, i )
		{
		if ( ! strcmp( event_sources[i]->Context().id(), interpreter_tag ) )
			got_src++;
		if ( ! event_src_list.is_member((char*)event_sources[i]->Context().id()) )
			{
			selector->AddSelectee( new ScriptSelectee( this, agent, event_sources[i]->Read_FD() ) );
			event_src_list.append(strdup(event_sources[i]->Context().id()));
			}
		}

	if ( ! got_src )
		selector->AddSelectee( new ScriptSelectee( this, agent, fileno( stdin ) ) );

	}

void ScriptClient::FD_Change( int fd, int add_flag )
	{
	if ( ! agent )
		return;

	if ( add_flag )
		selector->AddSelectee( new ScriptSelectee( this, agent, fd ) );
	else
		selector->DeleteSelectee( fd );
	}

char* which_include( const char* file_name )
	{
	const IValue *val;
	const IValue *pathv;
	const IValue *inclv;
	charptr *paths = 0;

	if ( (val = Sequencer::LookupVal( "system" )) && 
			val->Type() == TYPE_RECORD &&
			val->HasRecordElement( "path" ) &&
			(pathv = (const IValue*)(val->ExistingRecordElement( "path" ))) &&
			pathv != false_value &&
			pathv->Type() == TYPE_RECORD &&
			pathv->HasRecordElement( "include" ) &&
			(inclv = (const IValue*)(pathv->ExistingRecordElement("include"))) &&
			inclv != false_value && inclv->Type() == TYPE_STRING &&
			inclv->Length() )
		paths = inclv->StringPtr();

	if ( ! paths || file_name[0] == '/' || file_name[0] == '.' )
		{
		if ( access( file_name, R_OK ) == 0 )
			return strdup( file_name );
		else
			return 0;
		}

	char directory[1024];

	for ( int i = 0; i < inclv->Length(); i++ )
		if ( paths[i] && strlen(paths[i]) )
			{
			sprintf( directory, "%s/%s", paths[i], file_name );

			if ( access( directory, R_OK ) == 0 )
				return strdup( directory );
			}

	return 0;
	}
