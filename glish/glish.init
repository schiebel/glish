 # @(#) $Id$

const pi := 3.141592653589793238462643
const e  := 2.718281828459045235360287

func is_defined( const x )	length( symbol_value( x ) ) > 0

func is_boolean( const x )	type_name(x) == "boolean"
func is_byte( const x )		type_name(x) == "byte"
func is_short( const x )	type_name(x) == "short"
func is_integer( const x )	type_name(x) == "integer"
func is_float( const x )	type_name(x) == "float"
func is_double( const x )	type_name(x) == "double"
func is_complex( const x )	type_name(x) == "complex"
func is_dcomplex( const x )	type_name(x) == "dcomplex"
func is_string( const x )	type_name(x) == "string"
func is_record( const x )	type_name(x) == "record"
func is_function( const x )	type_name(x) == "function"

func is_agent( const x )
	type_name(x) == "agent" || (is_record(x) && has_field(x, "*agent*"))

func is_numeric( const x )
	sum(type_name(x) ==
		"boolean byte short integer float double complex dcomplex") > 0

func min(...)		range(...)[1]
func max(...)		range(...)[2]

func abs(val x)
	{
	if ( is_complex(x) || is_dcomplex(x) )
		return sqrt(real(x)^2 + imag(x)^2)

	else
		{
		mask := x < 0
		x[mask] := -x[mask]
		return x
		}
	}

func conj(x)
	{
	if ( is_complex(x) || is_dcomplex(x) )
		return complex(real(x), -imag(x))
	else
		return x
	}

func arg(x)
{
	if ( is_complex(x) || is_dcomplex(x) )
		{
		ret := atan(as_double(imag(x)) / as_double(real(x)))
		real_lt := real(x) < 0.0
		one := imag(x) >= 0.0 & real_lt
		two := imag(x) < 0.0 & real_lt
		ret[ one ] := pi - abs(ret[ one ])
		ret[ two ] := -pi + abs(ret[ two ])
		return ret
		}
	else
		{
		if ( is_numeric(x) )
			{
			mask := x < 0
			x[mask] := pi
			x[!mask] := 0
			return x
			}
		else
			print 'error: arg() takes a numeric argument'
		}
	return F
	}

func all(x) sum(!x) == 0
func any(x) sum(as_boolean(x)) > 0

len := length
ceil := ceiling

func ind(x) 1:len(x)

func paste(...,sep=' ')
	internal_paste(sep, ...)

func spaste(...)
	paste(...,sep='')

func has_field( const x, const field )
	{
	if ( is_record(x) )
		sum(field_names(x) == field) > 0
	else
		F
	}

func shell( ..., id=F, host=F, async=F, ping=F, suspend=F, input=F )
 	create_task( id, host, F, async, ping, suspend, input, ... )

func client( ..., id=F, host=F, async=F, ping=F, suspend=F, input=F )
 	create_task( id, host, T, async, ping, suspend, input, ... )

func frame ( parent=F, relief='flat',
		 borderwidth=2, side='top',
		 padx=0, pady=0, expand='both',
		 background='lightgrey',
		 width=70, height=50, cursor='', title='glish/tk' )
	create_graphic( 'frame', parent, relief, side, borderwidth, padx, pady, expand, background, width, height, cursor, title )

func button ( parent, text='button', type='plain', padx=7, pady=3, width=0, height=1, justify='center', font='',  relief='raised', borderwidth=2, foreground='black', background='lightgrey', disabled=F, value=T, fill='none' )
	create_graphic( 'button', parent, text, type, padx, pady, width, height, justify, font, relief, borderwidth, foreground, background, disabled, value, fill )

func scale ( parent, start=0, end=100, length=110, text='', orient='horizontal',
		 relief='flat', borderwidth=2, foreground='black', background='lightgrey', fill='' )
	create_graphic( 'scale', parent, start, end, length, text, orient, relief, borderwidth, foreground, background, fill )

func text ( parent, width=30, height=8, wrap='word', font='', disabled=F, text='', relief='flat', borderwidth=2, foreground='black', background='lightgrey', fill='both' )
	create_graphic( 'text', parent, width, height, wrap, font, disabled, text, relief, borderwidth, foreground, background, fill )

func scrollbar ( parent, orient='vertical', foreground='black', background='lightgrey' )
	create_graphic( 'scrollbar', parent, orient, foreground, background )

func label ( parent, text='label', justify='left', padx=4, pady=2, font='', width=0, relief='flat', borderwidth=2, foreground='black', background='lightgrey', fill='none' )
	create_graphic( 'label', parent, text, justify, padx, pady, font, width, relief, borderwidth, foreground, background, fill )

func entry ( parent, width=30, justify='left', font='', relief='sunken', borderwidth=2, foreground='black', background='lightgrey', disabled=F, show=T, exportselection=F, fill='x' )
	create_graphic( 'entry', parent, width, justify, font, relief, borderwidth, foreground, background, disabled, show, exportselection, fill )

func message ( parent, text='message', width=180, justify='left', font='', padx=4, pady=2, relief='flat', borderwidth=3, foreground='black', background='lightgrey', fill='none' )
	create_graphic( 'message', parent, text, width, justify, font, padx, pady, relief, borderwidth, foreground, background, fill )

func listbox ( parent, width=20, height=6, mode='browse', font='', relief='sunken', borderwidth=2, foreground='black', background='lightgrey', exportselection=F, fill='x' )
	create_graphic( 'listbox', parent, width, height, mode, font, relief, borderwidth, foreground, background, exportselection, fill )

func canvas ( parent, width=200, height=150, region=[0,0,1000,400], relief='sunken', borderwidth=2, background='lightgrey', fill='both' )
	create_graphic( 'canvas', parent, width, height, region, relief, borderwidth, background, fill )

func full_type_name( const x )
	{
	if ( type_name(x) == "record" )
		{
		full_name := 'record ['
		first_field := field_names(x)[1]
		for ( f in field_names(x) )
			{
			if ( f != first_field )
				full_name := spaste(full_name, ', ')
			full_name := spaste(full_name, f, "=",
						full_type_name(x[f]))
			}

		spaste(full_name, "]")
		}
	else
		{
		if ( length(x) != 1 )
			spaste(type_name(x), ' [', length(x), "]" )
		else
			type_name(x)
		}
	}

func relay( src, src_name, ref dest, dest_name="*" )
	{
	if ( dest_name == "*" )
		link src->[src_name] to dest->*
	else
		link src->[src_name] to dest->[dest_name]
	}

func relay_event( src, ref dest, name )
	{
	relay( src, name, dest, "*" )
	}

func relay_all( src, ref dest )
	{
	whenever src->* do
		dest->[$name]( $value )
	}

func birelay_event( ref agent1, ref agent2, name )
	{
	relay( agent1, name, agent2 )
	relay( agent2, name, agent1 )
	}

func birelay_all( ref agent1, ref agent2 )
	{
	relay_all( agent1, agent2 )
	relay_all( agent2, agent1 )
	}

func sort(x)
	{
	if ( len(x) <= 1 )
		return x

	pivot := x[random(1,len(x))]
	return [sort(x[x < pivot]), x[x == pivot], sort(x[x > pivot])]
	}

func sort_pair(x, y)
	{
	if ( len(x) <= 1 )
		return y

	pivot := x[random(1,len(x))]
	below := x < pivot
	equal := x == pivot
	above := x > pivot

	return [sort_pair(x[below], y[below]), y[equal],
			sort_pair(x[above], y[above])]
	}

func order(x)	sort_pair(x, 1:len(x))

func sync(ref c)	request c->["*sync*"]()

func array(init, ...)
	{
	if ( num_args(...) == 0 )
		return init

	if ( length(init) <= 0 && ! is_string(init) )
		{
		print "bad initializer"
		return F
		}

	if ( ! all(length(...) == 1) )
		{
		print "error non scalar parameter"
		return F
		}

	if ( min(...) <= 0 )
		{
		print "error 0 or negative parameter"
		return F
		}

	p := prod(...)
	value := []

	if ( length(init) > 0 )
		{
		if ( p % length(init) != 0 )
			value := [rep(init, as_integer(p / length(init))),
					init[1:(p % length(init))]]
		else
			value := rep(init, as_integer(p / length(init)))
		}
	else
		value := rep(init, p);

	if ( num_args(...) > 1 )
		value::shape := [...]

	return value
	}


# Given an ASCII table in "tbl" with the same number of columns in
# each row, returns a record of arrays with the given names, each
# array corresponding to a column in the table.
func table_to_arrays(tbl, array_names)
	{
	num_elements := len(tbl)
	num_arrays := len(split(tbl[1]))

	if ( num_arrays != len(array_names) )
		{
		print "mismatch between", len(array_names), "array names and",
			num_arrays, "arrays in table_to_arrays()"
		exit
		}

	arrays := as_double(split(tbl))
	mask := seq(0, len(arrays)-1, num_arrays)
	result := [=]

	for ( i in 1:num_arrays )
		result[array_names[i]] := arrays[mask + i]

	return result
	}
