// $Id$
// Copyright (c) 1993 The Regents of the University of California.
// Copyright (c) 1997 Associated Universities Inc.

//**
//** This is included by Value.cc and IValue.cc to implement
//** Value::StringVal and IValue::StringVal resp.
//**

#ifdef CLASS

static void append_buf( char* &buf, char* &buf_ptr, unsigned int& buf_size,
		const char* a = 0, const char* b = 0, const char* c = 0 )
	{
	a = a ? a : "";
	b = b ? b : "";
	c = c ? c : "";

	int buf_remaining = &buf[buf_size] - buf_ptr;
	int size_of_addition = strlen( a ) + strlen( b ) + strlen( c );

	while ( size_of_addition >= buf_remaining - 5 /* slop */ )
		{ // Need to grow the buffer.
		int buf_ptr_offset = buf_ptr - buf;

		buf_size *= 2;
		buf = (char*) realloc_memory( (void*) buf, buf_size );
		if ( ! buf )
			fatal->Report( "out of memory in append_buf()" );

		buf_ptr = buf + buf_ptr_offset;
		buf_remaining = &buf[buf_size] - buf_ptr;
		}

	*buf_ptr = '\0';
	strcat( buf_ptr, a );
	strcat( buf_ptr, b );
	strcat( buf_ptr, c );

	buf_ptr += size_of_addition;
	}


static char *format_error( const Value *val, char sep, 
				   int max_elements, int useAttributes )
	{
	if ( ! val || val->Type() != TYPE_FAIL )
		return 0;

	const attributeptr attr = val->AttributePtr();

	if ( ! attr )
		return strdup( "<fail>" );

	const Value *value1;
	int len = 0;
	char *intro = "<fail>";
	char *msg[9];
	int cnt = 7;

	msg[0] = msg[1] = msg[2] = msg[3] = msg[4] = msg[5] = msg[6] = msg[7] = msg[8] = 0;
	if ( (value1 = (*attr)["message"]) )
		{
		msg[0] = value1->StringVal(sep, max_elements, useAttributes );
		cnt += strlen(msg[0]);
		}

	if ( (value1 = (*attr)["file"]) && value1->Type() == TYPE_STRING )
		{
		msg[1] = value1->StringVal( sep, max_elements, useAttributes );
		cnt += strlen(msg[1]);
		}

	if ( (value1 = (*attr)["line"]) && value1->IsNumeric() )
		{
		int l = value1->IntVal();
		msg[2] = (char*) alloc_memory( sizeof(char)*48 );
		sprintf(msg[2],"Line: %d",l);
		cnt += strlen(msg[2]);
		}

	if ( (value1 = (*attr)["stack"]) &&
	     value1->Type() == TYPE_STRING &&
	     (len = value1->Length()) )
		{
		charptr *stack = value1->StringPtr(0);
		int l = strlen(stack[--len]);
		msg[3] = (char*) alloc_memory( sizeof(char)*(l+10) );
		strcpy(msg[3],"Stack:\t");
		strcat(msg[3],stack[len]);
		strcat(msg[3],"()");
		cnt += l + 13;
		for (int x=4; x < 8 && len; x++)
			{
			l = strlen(stack[--len]);
			msg[x] = (char*) alloc_memory( sizeof(char)*(l+4) );
			strcpy(msg[x],"\t");
			strcat(msg[x],stack[len]);
			strcat(msg[x],"()");
			cnt += l + 4;
			}
		if ( len )
			{
			msg[8] = "\t...";
			cnt += 5;
			}
		}

	// Add some for line feeds etc...
	char *result = (char*) alloc_memory( sizeof(char)*(cnt + 24) );

	strcpy(result, intro);
	if ( msg[0] ) { strcat(result, ": "); strcat(result, msg[0]); }
	if ( msg[1] ) { strcat(result, "\n\tFile: "); strcat(result, msg[1]); }
	if ( msg[2] )
		{
		if ( msg[1] ) strcat( result, ", ");
		else strcat( result, "\n\t");
		strcat( result, msg[2] );
		}
	for ( int x=3; x <= 8; x++ )
		if ( msg[x] ) { strcat(result, "\n\t"); strcat(result, msg[x]); }

	for ( int i=0; i < 8; i++ )
		if ( msg[i] ) free_memory( msg[i] );

	return result;
	}


char* CLASS::StringVal( char sep, int max_elements,
				int useAttributes, Str &err ) const
	{
	glish_type type = Type();
	int length = kernel.Length();

	if ( IsRef() )
		return Deref()->StringVal( sep, max_elements, useAttributes );
	if ( type == TYPE_RECORD )
		return RecordStringVal( sep, max_elements, useAttributes, err );
	if ( type == TYPE_FAIL )
		return format_error( this, sep, max_elements, useAttributes );
	if ( length == 0 )
		return strdup( "" );

	char *ns_desc = GetNSDesc( );
	if ( ns_desc ) return ns_desc;

	unsigned int buf_size = 0;

	// Make a guess as to a probable good size for buf.
	if ( type == TYPE_STRING )
		{
		buf_size = strlen( StringPtr(0)[0] ) * (length + 1);
		if ( buf_size == 0 )
			buf_size = 8;
		}

	else if ( type == TYPE_COMPLEX  || type == TYPE_DCOMPLEX )
		buf_size = length * 16 * 2 + 1;

	else if ( type == TYPE_FLOAT  || type == TYPE_DOUBLE )
		buf_size = length * 16;

	else
		buf_size = length * 8;

	char* buf = (char*) alloc_memory( sizeof(char)*buf_size );
	if ( ! buf )
		fatal->Report( "out of memory in Value::StringVal()" );

	char* buf_ptr = buf;

	if ( type != TYPE_STRING && length > 1 )
		{
		// Insert []'s around value.
		*buf_ptr++ = '[';
		}

	glish_bool* bool_ptr = 0;
	byte* byte_ptr = 0;
	short* short_ptr = 0;
	int* int_ptr = 0;
	float* float_ptr = 0;
	double* double_ptr = 0;
	complex* complex_ptr = 0;
	dcomplex* dcomplex_ptr = 0;
	charptr* string_ptr = 0;
	const char *flt_prec = 0;
#ifdef DOIVAL
	regexptr* regex_ptr = 0;
	fileptr* file_ptr = 0;
#endif

	switch ( VecRefDeref()->Type() )
		{
#define ASSIGN_PTR(tag,ptr_name,accessor,extra)				\
	case tag:							\
		ptr_name = accessor(0);					\
		extra							\
		break;

		ASSIGN_PTR(TYPE_BOOL,bool_ptr,BoolPtr,)
		ASSIGN_PTR(TYPE_INT,int_ptr,IntPtr,)
		ASSIGN_PTR(TYPE_BYTE,byte_ptr,BytePtr,)
		ASSIGN_PTR(TYPE_SHORT,short_ptr,ShortPtr,)
		ASSIGN_PTR(TYPE_FLOAT,float_ptr,FloatPtr,flt_prec = print_decimal_prec( AttributePtr() );)
		ASSIGN_PTR(TYPE_DOUBLE,double_ptr,DoublePtr,flt_prec = print_decimal_prec( AttributePtr() );)
		ASSIGN_PTR(TYPE_COMPLEX,complex_ptr,ComplexPtr,flt_prec = print_decimal_prec( AttributePtr() );)
		ASSIGN_PTR(TYPE_DCOMPLEX,dcomplex_ptr,DcomplexPtr,flt_prec = print_decimal_prec( AttributePtr() );)
		ASSIGN_PTR(TYPE_STRING,string_ptr,StringPtr,)
#ifdef DOIVAL
		ASSIGN_PTR(TYPE_REGEX,regex_ptr,RegexPtr,)
		ASSIGN_PTR(TYPE_FILE,file_ptr,FilePtr,)

#define PLACE_REGEX(indx, str_buffer)					\
	case TYPE_REGEX:						\
		str_buffer = regex_ptr[ indx ]->Description( );		\
		break;
#define PLACE_FILE(indx, str_buffer)					\
	case TYPE_FILE:							\
		str_buffer = file_ptr[ indx ]->Description( );		\
		break;
#else
#define PLACE_REGEX(x,y)
#define PLACE_FILE(x,y)
#endif

		default:
			fatal->Report( "bad type in Value::StringVal()" );
		}


// Macro to generate the text corresponding to a single element of a given type.
#define PLACE_ELEMENT_ACTION(buffer,str_buffer,indx,FLOAT_PRECISION)	\
	case TYPE_BOOL:							\
		strcpy( buffer, bool_ptr[indx] ? "T" : "F" );		\
		break;							\
									\
	case TYPE_BYTE:							\
		sprintf( buffer, "%d", byte_ptr[indx] );		\
		break;							\
									\
	case TYPE_SHORT:						\
		sprintf( buffer, "%d", short_ptr[indx] );		\
		break;							\
									\
	case TYPE_INT:							\
		sprintf( buffer, "%d", int_ptr[indx] );			\
		break;							\
									\
	case TYPE_FLOAT:						\
		sprintf( buffer, FLOAT_PRECISION, float_ptr[indx] );	\
		break;							\
									\
	case TYPE_DOUBLE:						\
		sprintf( buffer, FLOAT_PRECISION, double_ptr[indx] );	\
		break;							\
									\
	case TYPE_COMPLEX:						\
		{							\
		char t[64];						\
		sprintf( t, FLOAT_PRECISION, complex_ptr[indx].r );	\
		strcpy( buffer, t);					\
		if ( complex_ptr[indx].i >= 0.0 ) 			\
			strcat( buffer, "+" );				\
		sprintf( t, FLOAT_PRECISION, complex_ptr[indx].i );	\
		strcat( t, "i");					\
		strcat( buffer, t);					\
		}							\
		break;							\
									\
	case TYPE_DCOMPLEX:						\
		{							\
		char t[64];						\
		sprintf( t, FLOAT_PRECISION, dcomplex_ptr[indx].r );	\
		strcpy( buffer, t);					\
		if ( dcomplex_ptr[indx].i >= 0.0 ) 			\
			strcat( buffer, "+" );				\
		sprintf( t, FLOAT_PRECISION, dcomplex_ptr[indx].i );	\
		strcat( t, "i");					\
		strcat( buffer, t);					\
		}							\
		break;							\
									\
	case TYPE_STRING:						\
		str_buffer = string_ptr[ indx ];			\
		break;							\
	PLACE_REGEX(indx, str_buffer)					\
	PLACE_FILE(indx, str_buffer)

// Generate text for an element, translating subref indices if needed.
#define PLACE_ELEMENT(buffer,str_buffer,indx,alloced)			\
	switch ( type )							\
		{							\
		PLACE_ELEMENT_ACTION(buffer,str_buffer,indx,flt_prec)	\
									\
		case TYPE_SUBVEC_REF:					\
			{						\
			VecRef* ref = VecRefPtr();			\
			int erri = 0;					\
			int index = ref->TranslateIndex( indx, &erri );	\
			if ( erri )					\
				{					\
				err = strFail( "invalid sub-vector" );	\
				free_memory( alloced );			\
				return strdup( " " );			\
				}					\
			switch ( ref->Type() )				\
				{					\
				PLACE_ELEMENT_ACTION(buffer,str_buffer,index,flt_prec)\
									\
				default:				\
					fatal->Report(			\
				    "bad type in Value::StringVal()" ); \
				} 					\
			}						\
			break;						\
									\
		default:						\
			fatal->Report(					\
			    "bad type in Value::StringVal()" );		\
		}


	char numeric_buf[1024];

	const attributeptr attr = AttributePtr();
	const Value* shape_val = 0;
	int shape_len = 0;

	if ( ! useAttributes || ! attr || ! (shape_val = (*attr)["shape"]) || 
	     ! shape_val->IsNumeric() ||
	     (shape_len = shape_val->Length()) <= 1 )
		{ // not an n-D array.
		for ( int i = 0; i < length && ( ! max_elements ||
		      i < max_elements) ; ++i )
			{
			const char* addition = numeric_buf;

			PLACE_ELEMENT(numeric_buf, addition, i, buf);
			append_buf( buf, buf_ptr, buf_size, addition );

			if ( i < length - 1 )
				// More to come.
				*buf_ptr++ = sep;
			}

		if ( max_elements && length > max_elements )
			append_buf( buf, buf_ptr, buf_size, "... " );
		if ( type != TYPE_STRING && length > 1 )
			{
			// Insert []'s around value.
			append_buf( buf, buf_ptr, buf_size, "] " );
			*buf_ptr = '\0';
			}

		return buf;
		}

	// Okay, from this point on it's an n-D array.
	static char indent[] = "    ";

	// Later the pivots for outputting by planes can be made variable
	int r = 0;
	int c = 1;

	// How many element have we output...
	int element_count = 0;

	int shape_is_copy = 0;
	int* shape = shape_val->CoerceToIntArray( shape_is_copy, shape_len );

	// Store for setting up a plane in advance to get the proper
	// spacing for the columns.  Note that these and the arrays
	// created just below are static, so we don't free them on exit.
	static int column_width_len = 64;
	static int* column_width = (int*) alloc_memory( sizeof(int)*column_width_len );

	// Arrays for iterating through the matrix.
	static int indices_len = 32;
	static int* indices = (int*) alloc_memory( sizeof(int)*indices_len );
	static int* factor = (int*) alloc_memory( sizeof(int)*indices_len );

	// Resize arrays as necessary.
	while ( shape[c] > column_width_len )
		{
		column_width_len *= 2;
		column_width = (int*) realloc_memory( (void*) column_width,
					column_width_len * sizeof(int) );
		if ( ! column_width )
			fatal->Report( "out of memory in Value::StringVal()" );
		}

	while ( shape_len > indices_len )
		{
		indices_len *= 2;
		indices = (int*) realloc_memory( (void*) indices,
						indices_len * sizeof(int) );
		factor = (int*) realloc_memory( (void*) factor,
					indices_len * sizeof(int) );
		if ( ! indices || ! factor )
			fatal->Report( "out of memory in Value::StringVal()" );
		}

	// Calculate the size and the offset for the columns.
	int size = 1;
	int offset = 0;
	for ( int i = 0; i < shape_len; ++i )
		{
		indices[i] = 0;
		factor[i] = size;
		size *= shape[i];
		}

	// Check to see if the vector length and the shape jive.
	if ( size > length ) 
		{
		warn->Report( "\"::shape\"/length mismatch" );
		free_memory( buf );
		if ( shape_is_copy )
			free_memory( shape );
		return StringVal( sep );
		}

	int max_free = shape_len-1;

	if ( shape_len > 2 )
		for ( max_free = shape_len-1; max_free > 0; --max_free )
			if ( max_free != r && max_free != c )
				break;

	while ( indices[max_free] < shape[max_free] && ( ! max_elements ||
			element_count < max_elements) )
		{
		// Output the plane label
		for ( LOOPDECL i = 0; i < shape_len; ++i )
			{
			if ( i == r )
				sprintf( numeric_buf, "1:%d", shape[r] );
			else if ( i != c )
				sprintf( numeric_buf, "%d", indices[i] + 1 );
			else
				numeric_buf[0] = '\0';

			if ( i < shape_len - 1 )
				strcat( numeric_buf, "," );
			else
				strcat( numeric_buf, "]\n" );

			append_buf( buf, buf_ptr, buf_size, i==0 ? "[" : 0,
					numeric_buf );
			}

		// Calculate column widths.
		for ( indices[r] = 0; indices[r] < shape[r]; ++indices[r] )
			for ( indices[c] = 0; indices[c] < shape[c] - 1;
			      ++indices[c] )
				{
				offset = 0;
				for ( LOOPDECL i = 0; i < shape_len; ++i )
					offset += factor[i] * indices[i];

				char store[256];
				const char* addition = store;

				PLACE_ELEMENT(store,addition,offset,buf)

				int add_len = strlen( addition );
				if ( indices[r] == 0 || 
				     add_len > column_width[indices[c]] )
					column_width[indices[c]] = add_len;
				}

		// Output plane.
		for ( indices[r] = 0; indices[r] < shape[r] && ( !max_elements ||
			element_count < max_elements) ; ++indices[r] )
			{
			for ( indices[c] = 0; indices[c] < shape[c] && ( !max_elements ||
				element_count < max_elements); ++indices[c] )
				{
				offset = 0;
				for ( LOOPDECL i = 0; i < shape_len; ++i )
					offset += factor[i] * indices[i];

				const char* addition = numeric_buf;
				PLACE_ELEMENT(numeric_buf,addition,offset,buf);

				element_count++;
				char affix[256];
				if ( max_elements && element_count >= max_elements )

					strcpy(affix, " ... ");

				else if ( indices[c] < shape[c] - 1 )
					{
					int n = column_width[indices[c]] -
						strlen( addition ) + 1;

					LOOPDECL i = 0;
					for ( ; i < n; ++i )
						affix[i] = ' ';
					affix[i] = '\0';
					}

				else if ( offset != size - 1 )
					{
					affix[0] = '\n';
					affix[1] = '\0';
					}
				else
					affix[0] = '\0';

				append_buf( buf, buf_ptr, buf_size,
						indices[c] == 0 ? indent : 0,
						addition, affix );
				}
			}

		// Increment counters.
		for ( LOOPDECL i = 0; i <= max_free; ++i )
			{
			if ( i == r || i == c )
				continue;
			else if ( ++indices[i] < shape[i] )
				break;
			else if ( i != max_free )
				indices[i] = 0;
			}
		}

	if ( shape_is_copy )
		free_memory( shape );

	append_buf( buf, buf_ptr, buf_size, "]" );

	return buf;
	}


#endif
